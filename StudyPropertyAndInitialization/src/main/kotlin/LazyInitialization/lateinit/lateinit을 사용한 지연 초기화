lateinit을 사용한 지연 초기화

기본 자료형들은 생성자에서 반드시 초기화되어야 하지만 의존성이 있는 초기화나 유닛 테스트를 위한 코드를
설정에 의한 초기화를 할 때는 매번 초기화하기가 불편하다.

예를 들어
Car 클래스의 초기화 부분이 Engine 클래스와 의존성을 가질 때 Engine 객체가 생성되지 않으면
완전하게 초기화할 수 없습니다.
이처럼 특정 객체의 의존성이 있는 경우에는 지연 초기화를 해야 한다.
또 해당 자료형의 프로퍼티를 즉시 사용하지 않는데도 미리 생성해서 초기화한다면
메모리가 사용되어 낭비될 수 있다.
모듈별로 소스 코드를 테스트하는 유닛 테스트를 할 때는 임시적으로 객체를 생성시켜야 하는 경우도 많다.
이때도 지연 초기화를 사용한다.

--------------------------------------------------------------------------------
프로퍼티 지연 초기화하기
먼저 프로퍼티를 지연 초기화하는 방법을 보자.

클래스를 선언할 때 프로퍼티 선언은 null을 허용하지 않는다.
하지만 지연 초기화를 위한 lateinit 키워드를 사용하면 프로퍼티에 값이 바로 할당되지 않아도
컴파일러에서 허용하게 된다.
컴파일러에게 나중에 할당한다고 알려주는 것!
단, 실행할 때까지 값이 비어 있는 상태면 오류를 유발할 수 있으니 주의!

프로퍼티를 초기화하는 방법은 주 생성자에서 초기화, init 블록 초기화, 부 생성자 초기화,
매개변수의 기본값 초기화 등을 사용할 수 있었다. 생성자를 통한 매개변수 초기화를 제외하고 몇 가지를 살펴보면
다음과 같다.
// init 블록을 통한 초기화
class Person {
    var name: String
    init {
        name = "NONAME" // 프로퍼티 name이 "NONAME"으로 초기화
    }
}

위의 예제는 프로퍼티에 대한 초기화를 init 블록을 통해서 하는 것을 보여준다.
다음은 프로퍼티 name에 할당 연산자(=)를 사용해 기본값을 넣어 초기화하는 것을 나타낸다.
class Person {
    var name: String = "NONAME" // 선언과 동시에 기본값 초기화
}

그러면 이제 지연 초기화를 위해 lateinit을 사용해 보자.
lateinit은 var로 선언된 프로퍼티에만 사용할 수 있다는 제한이 있다.
또 프로퍼티에 대한 게터와 세터를 사용할 수 없다.

lateinit의 제한
- var로 선언된 프로퍼티만 가능하다.
- 프로퍼티에 대한 게터와 세터를 사용할 수 없다.
